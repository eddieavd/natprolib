// vim: set ft=cpp:
//
//
//      natprolib
//      prefix_vector
//

#pragma once


#include <algorithm>

#include <util/mem.hpp>
#include <util/util.hpp>
#include <util/traits.hpp>
#include <util/iterator.hpp>
#include <util/split_buffer.hpp>

#include <container/array>
#include <container/vector>


namespace npl
{


template< typename T, typename Allocator >
class _prefix_vector_base;

template< typename T, typename Allocator >
class prefix_vector;


struct prefix_vector_iterator_tag : public random_access_iterator_tag {};

template< typename T >
struct is_prefix_vector_iterator : public has_same_npl_iterator_category< iterator_traits< T >, prefix_vector_iterator_tag > {};

template< typename T >
inline constexpr bool is_prefix_vector_iterator_v = is_prefix_vector_iterator< T >::value;


template< typename T, typename Allocator >
class _prefix_vector_base
        : protected _vector_base< T, Allocator >
{
protected:
        template< bool C, typename T_ = T >
        class _prefix_vector_iterator
                : public iterator< C, T_ >
        {
                friend class _prefix_vector_iterator< !C, T_ >;
        public:
                using                 _base = iterator< C, T_ >                       ;
                using         _alloc_traits = std::allocator_traits< Allocator >      ;
                using       difference_type = typename _alloc_traits::difference_type ;
                using npl_iterator_category = prefix_vector_iterator_tag              ;

                explicit constexpr _prefix_vector_iterator ( typename _base::pointer _ptr_ ) : _base( _ptr_ ) {}
        };

        using          _base = _vector_base< T, Allocator >    ;
        using       iterator = _prefix_vector_iterator< false > ;
        using const_iterator = _prefix_vector_iterator<  true > ;
        using allocator_type = typename _base::allocator_type  ;

        _prefix_vector_base (                                 ) noexcept( std::is_nothrow_default_constructible_v< allocator_type > ) : _base() {}
        _prefix_vector_base ( allocator_type const &  _alloc_ )          : _base(           _alloc_   ) {}
        _prefix_vector_base ( allocator_type       && _alloc_ ) noexcept : _base( NPL_MOVE( _alloc_ ) ) {}
};

template< typename T, typename Allocator = std::allocator< T > >
class prefix_vector
        : _prefix_vector_base< T, Allocator >
{
private:
        using                   _base = _prefix_vector_base< T, Allocator > ;
        using                   _self =  prefix_vector                      ;
        using _default_allocator_type = std::allocator< T >                ;
public:
        using      value_type = T                               ;
        using  allocator_type = Allocator                       ;
        using   _alloc_traits = typename _base::_alloc_traits   ;
        using       reference = typename _base::reference       ;
        using const_reference = typename _base::const_reference ;
        using       size_type = typename _base::size_type       ;
        using difference_type = typename _base::difference_type ;
        using         pointer = typename _base::pointer         ;
        using   const_pointer = typename _base::const_pointer   ;

        using               iterator = typename _base::iterator       ;
        using         const_iterator = typename _base::const_iterator ;
        using       reverse_iterator = reverse_iter<       iterator > ;
        using const_reverse_iterator = reverse_iter< const_iterator > ;

        static_assert( ( std::is_same_v< typename allocator_type::value_type, value_type > ),
                        "allocator_type::value_type != prefix_vector::value_type" );

        prefix_vector () noexcept( std::is_nothrow_default_constructible_v< allocator_type > ) {}

        explicit prefix_vector ( allocator_type const & _alloc_ ) noexcept : _base( _alloc_ ) {}

        explicit prefix_vector ( size_type const _count_                                 );
        explicit prefix_vector ( size_type const _count_, allocator_type const & _alloc_ );

        prefix_vector ( size_type const _count_, value_type const & _val_                                 );
        prefix_vector ( size_type const _count_, value_type const & _val_, allocator_type const & _alloc_ );

        template< typename PrefixIterator >
        prefix_vector ( PrefixIterator _first_,
                        typename std::enable_if_t<
                                                        is_prefix_vector_iterator_v< PrefixIterator > &&
                                                        std::is_constructible_v
                                                        <
                                                                value_type,
                                                                typename std::iterator_traits< PrefixIterator >::reference
                                                        >,
                                                        PrefixIterator
                                                > _last_ );

        template< typename PrefixIterator >
        prefix_vector ( PrefixIterator _first_, PrefixIterator _last_, allocator_type const & _alloc_,
                        typename std::enable_if_t<
                                                        is_prefix_vector_iterator_v< PrefixIterator > &&
                                                        std::is_constructible_v
                                                        <
                                                                value_type,
                                                                typename std::iterator_traits< PrefixIterator >::reference
                                                        > > * = 0 );

        template< typename InputIterator >
        prefix_vector ( InputIterator _first_,
                        typename std::enable_if_t<
                                                         is_cpp17_input_iterator_v  < InputIterator > &&
                                                        !is_cpp17_forward_iterator_v< InputIterator > &&
                                                        !is_prefix_vector_iterator_v < InputIterator > &&
                                                         std::is_constructible_v
                                                         <
                                                                value_type,
                                                                typename std::iterator_traits< InputIterator >::reference
                                                         >,
                                                         InputIterator
                                                > _last_ );
        template< typename InputIterator >
        prefix_vector ( InputIterator _first_, InputIterator _last_, allocator_type const & _alloc_,
                        typename std::enable_if_t<
                                                         is_cpp17_input_iterator_v  < InputIterator > &&
                                                        !is_cpp17_forward_iterator_v< InputIterator > &&
                                                        !is_prefix_vector_iterator_v < InputIterator > &&
                                                         std::is_constructible_v
                                                         <
                                                                value_type,
                                                                typename std::iterator_traits< InputIterator >::reference
                                                         > > * = 0 );

        template< typename ForwardIterator >
        prefix_vector ( ForwardIterator _first_,
                        typename std::enable_if_t<
                                                         is_cpp17_forward_iterator_v< ForwardIterator > &&
                                                        !is_prefix_vector_iterator_v < ForwardIterator > &&
                                                        std::is_constructible_v
                                                        <
                                                                value_type,
                                                                typename std::iterator_traits< ForwardIterator >::reference
                                                        >,
                                                        ForwardIterator
                                                > _last_ );

        template< typename ForwardIterator >
        prefix_vector ( ForwardIterator _first_, ForwardIterator _last_, allocator_type const & _alloc_,
                        typename std::enable_if_t<
                                                         is_cpp17_forward_iterator_v< ForwardIterator > &&
                                                        !is_prefix_vector_iterator_v < ForwardIterator > &&
                                                        std::is_constructible_v
                                                        <
                                                                value_type,
                                                                typename std::iterator_traits< ForwardIterator >::reference
                                                        > > * = 0 );

        ~prefix_vector ()
        {
                _annotate_delete();
        }

        prefix_vector ( prefix_vector const & _other_                                              );
        prefix_vector ( prefix_vector const & _other_, _identity< allocator_type > const & _alloc_ );

        prefix_vector & operator= ( prefix_vector const & _other_ );

        prefix_vector ( prefix_vector && _other_                                              ) noexcept;
        prefix_vector ( prefix_vector && _other_, _identity< allocator_type > const & _alloc_ );

        prefix_vector & operator= ( prefix_vector && _other_ )
                noexcept( ( noexcept_move_assign_container_v< allocator_type, _alloc_traits > ) );

        prefix_vector ( std::initializer_list< value_type > _list_                                 );
        prefix_vector ( std::initializer_list< value_type > _list_, allocator_type const & _alloc_ );

        prefix_vector & operator= ( std::initializer_list< value_type > _list_ )
        { assign( _list_.begin(), _list_.end() ); return *this; }

        template< typename PrefixIterator >
        typename std::enable_if_t
        <
                is_prefix_vector_iterator_v< PrefixIterator > &&
                std::is_constructible_v
                <
                        value_type,
                        typename std::iterator_traits< PrefixIterator >::reference
                >,
                void
        >
        assign ( PrefixIterator _first_, PrefixIterator _last_ );

        template< typename InputIterator >
        typename std::enable_if_t
        <
                 is_cpp17_input_iterator_v  < InputIterator > &&
                !is_prefix_vector_iterator_v < InputIterator > &&
                 std::is_constructible_v
                 <
                        value_type,
                        typename std::iterator_traits< InputIterator >::reference
                 >,
                 void
        >
        assign ( InputIterator _first_, InputIterator _last_ );

#if 0
        template< typename ForwardIterator >
        typename std::enable_if_t
        <
                 is_cpp17_forward_iterator_v< ForwardIterator > &&
                !is_prefix_vector_iterator_v < ForwardIterator > &&
                 std::is_constructible_v
                 <
                        value_type,
                        typename std::iterator_traits< ForwardIterator >::reference
                 >,
                 void
        >
        assign ( ForwardIterator _first_, ForwardIterator _last_ );

        void assign ( size_type const _count_, const_reference _val_ );
#endif

        void assign ( std::initializer_list< value_type > _list_ )
        { assign( _list_.begin(), _list_.end() ); }

        allocator_type get_allocator () const noexcept
        { return this->_alloc(); }

              iterator begin ()       noexcept;
              iterator   end ()       noexcept;
        const_iterator begin () const noexcept;
        const_iterator   end () const noexcept;

        reverse_iterator rbegin () noexcept
        { return reverse_iterator( end() ); }

        reverse_iterator rend () noexcept
        { return reverse_iterator( begin() ); }

        const_reverse_iterator rbegin () const noexcept
        { return const_reverse_iterator( end() ); }

        const_reverse_iterator rend () const noexcept
        { return const_reverse_iterator( begin() ); }

        const_iterator cbegin () const noexcept
        { return begin(); }

        const_iterator cend () const noexcept
        { return end(); }

        const_reverse_iterator crbegin () const noexcept
        { return rbegin(); }

        const_reverse_iterator crend () const noexcept
        { return rend(); }

        NPL_NODISCARD size_type size () const noexcept
        { return static_cast< size_type >( this->end_ - this->begin_ ); }

        NPL_NODISCARD size_type capacity () const noexcept
        { return _base::capacity(); }

        NPL_NODISCARD bool empty () const noexcept
        { return this->begin_ == this->end_; }

        size_type max_size () const noexcept;

        void reserve ( size_type const _size_ );

        void shrink_to_fit () noexcept;

        NPL_ALWAYS_INLINE       reference operator[] ( size_type const _index_ )       noexcept;
        NPL_ALWAYS_INLINE const_reference operator[] ( size_type const _index_ ) const noexcept;

        bool   operator== ( prefix_vector< T, Allocator > const & _rhs_ ) const noexcept;
        bool   operator!= ( prefix_vector< T, Allocator > const & _rhs_ ) const noexcept;
        auto   operator+  ( prefix_vector< T, Allocator > const & _rhs_ ) const         ;
        auto & operator+= ( prefix_vector< T, Allocator > const & _rhs_ )       noexcept;
        auto   operator-  ( prefix_vector< T, Allocator > const & _rhs_ ) const         ;
        auto & operator-= ( prefix_vector< T, Allocator > const & _rhs_ )       noexcept;

        // replace the following with some type of range class with both begin and end

        template< typename PrefixIterator >
        typename std::enable_if_t
        <
                is_prefix_vector_iterator_v< PrefixIterator > &&
                std::is_constructible_v
                <
                        value_type,
                        typename std::iterator_traits< PrefixIterator >::reference
                >,
                bool
        >
        operator== ( PrefixIterator _first_ ) const noexcept;

        template< typename InputIterator >
        typename std::enable_if_t
        <
                !is_prefix_vector_iterator_v < InputIterator > &&
                !is_cpp17_forward_iterator_v< InputIterator > &&
                 is_cpp17_input_iterator_v  < InputIterator > &&
                 std::is_constructible_v
                 <
                        value_type,
                        typename std::iterator_traits< InputIterator >::reference
                 >,
                 bool
        >
        operator== ( InputIterator _first_ ) const noexcept;

        template< typename ForwardIterator >
        typename std::enable_if_t
        <
                !is_prefix_vector_iterator_v< ForwardIterator > &&
                 is_cpp17_forward_iterator_v< ForwardIterator > &&
                 std::is_constructible_v
                 <
                        value_type,
                        typename std::iterator_traits< ForwardIterator >::reference
                 >,
                 bool
        >
        operator== ( ForwardIterator _first_ ) const noexcept;

        NPL_ALWAYS_INLINE       reference at ( size_type const _index_ )       noexcept;
        NPL_ALWAYS_INLINE const_reference at ( size_type const _index_ ) const noexcept;

        NPL_ALWAYS_INLINE NPL_FLATTEN value_type element_at ( size_type const _index_ ) const noexcept;

        NPL_ALWAYS_INLINE value_type range ( size_type const _x_, size_type const _y_ ) const noexcept;

          ////////////////////
         // 2D overloads ////
        ////////////////////

        template< typename U = _self >
        NPL_ALWAYS_INLINE NPL_FLATTEN
        enable_2d_container_base_t< U > const &
        at ( size_type const _x_, size_type const _y_ ) const noexcept
        {
                return at( _x_ ).at( _y_ );
        }

        template< typename U = _self >
        NPL_ALWAYS_INLINE NPL_FLATTEN
        enable_2d_container_base_t< U > &
        at ( size_type const _x_, size_type const _y_ ) noexcept
        {
                return at( _x_ ).at( _y_ );
        }

        template< typename U = _self >
        NPL_ALWAYS_INLINE NPL_FLATTEN
        enable_2d_range_container_base_t< U >
        element_at ( size_type const _x_, size_type const _y_ ) const noexcept
        {
                return range( _x_, _y_, _x_, _y_ );
        }

        template< typename U = _self >
        NPL_ALWAYS_INLINE NPL_FLATTEN
        enable_2d_range_container_base_t< U >
        range ( size_type const _x1_, size_type const _y1_, size_type const _x2_, size_type const _y2_ ) const noexcept
        {
                return  _x1_ == 0 ?
                        at( _x2_ ).range( _y1_, _y2_ ) :
                        at( _x2_ ).range( _y1_, _y2_ ) - at( _x1_ - 1 ).range( _y1_, _y2_ );
        }

        //////////////////

          ////////////////////
         // 3D overloads ////
        ////////////////////

        template< typename U = _self >
        NPL_ALWAYS_INLINE NPL_FLATTEN
        enable_3d_container_base_t< U > const &
        at ( size_type const _x_, size_type const _y_, size_type const _z_ ) const noexcept
        {
                return at( _x_ ).at( _y_ ).at( _z_ );
        }

        template< typename U = _self >
        NPL_ALWAYS_INLINE NPL_FLATTEN
        enable_3d_container_base_t< U > &
        at ( size_type const _x_, size_type const _y_, size_type const _z_ ) noexcept
        {
                return at( _x_ ).at( _y_ ).at( _z_ );
        }

        template< typename U = _self >
        NPL_ALWAYS_INLINE NPL_FLATTEN
        enable_3d_range_container_base_t< U >
        element_at ( size_type const _x_, size_type const _y_, size_type const _z_ ) const noexcept
        {
                return range( _x_, _y_, _z_, _x_, _y_, _z_ );
        }

        template< typename U = _self >
        NPL_ALWAYS_INLINE NPL_FLATTEN
        enable_3d_range_container_base_t< U >
        range ( size_type const _x1_, size_type const _y1_, size_type const _z1_,
                size_type const _x2_, size_type const _y2_, size_type const _z2_ ) const noexcept
        {
                return  _x1_ == 0 ?
                        at( _x2_ ).range( _y1_, _z1_, _y2_, _z2_ ) :
                        at( _x2_ ).range( _y1_, _z1_, _y2_, _z2_ ) - at( _x1_ - 1 ).range( _y1_, _z1_, _y2_, _z2_ );
        }

        template< typename U = _self >
        NPL_ALWAYS_INLINE NPL_FLATTEN
        auto range () const noexcept
        {
                NPL_ASSERT( !empty(), "prefix_vector::range: called on empty prefix_vector" );

                if constexpr( is_2d_range_container_v< U > )
                {
                        return at( size() - 1 ).range();
                }
                else
                {
                        return at( size() - 1 );
                }
        }

        //////////////////

        reference front () noexcept
        {
                NPL_ASSERT( !empty(), "prefix_vector::front: called on empty prefix_vector" );

                return *this->begin_;
        }

        const_reference front () const noexcept
        {
                NPL_ASSERT( !empty(), "prefix_vector::front: called on empty prefix_vector" );

                return *this->begin_;
        }

        const_reference cfront () const noexcept
        {
                return front();
        }

        reference back () noexcept
        {
                NPL_ASSERT( !empty(), "prefix_vector::back: called on empty prefix_vector" );

                return *( this->end_ - 1 );
        }

        const_reference back () const noexcept
        {
                NPL_ASSERT( !empty(), "prefix_vector::back: called on empty prefix_vector" );

                return *( this->end_ - 1 );
        }

        const_reference cback () const noexcept
        {
                return back();
        }

        value_type * data () noexcept
        { return mem::to_address( this->begin_ ); }

        value_type const * data () const noexcept
        { return mem::to_address( this->begin_ ); }

        template< typename Arg >
        void _emplace_back ( Arg&& _arg_ )
        {
                emplace_back( NPL_FWD( _arg_ ) );
        }

        void push_back ( const_reference _val_ );

        template< typename... Args >
        void push_back ( const_reference _val_, Args... _args_ )
        {
                push_back( _val_ );
                push_back( _args_... );
        }

        void push_back ( value_type && _val_ );

        template< typename... Args >
        void push_back ( value_type && _val_, Args... _args_ )
        {
                push_back( _val_ );
                push_back( _args_... );
        }

        template< typename... Args >
        reference emplace_back ( Args&&... _args_ );

        void pop_back ();

#if 0
        iterator insert ( const_iterator _position_, const_reference    _val_ );
        iterator insert ( const_iterator _position_, value_type      && _val_ );

        template< typename... Args >
        iterator emplace ( const_iterator _position_, Args&&... _args_ );

        iterator insert ( const_iterator _position_, size_type const _count_, const_reference _val_ );

        template< typename PrefixIterator >
        typename std::enable_if_t
        <
                is_prefix_vector_iterator_v< PrefixIterator > &&
                std::is_constructible_v
                <
                        value_type,
                        typename std::iterator_traits< PrefixIterator >::reference
                >,
                iterator
        >
        insert ( const_iterator _position_, PrefixIterator _first_, PrefixIterator _last_ );

        template< typename InputIterator >
        typename std::enable_if_t
        <
                 is_cpp17_input_iterator_v  < InputIterator > &&
                !is_cpp17_forward_iterator_v< InputIterator > &&
                !is_prefix_vector_iterator_v < InputIterator > &&
                 std::is_constructible_v
                 <
                        value_type,
                        typename std::iterator_traits< InputIterator >::reference
                 >,
                 iterator
        >
        insert ( const_iterator _position_, InputIterator _first_, InputIterator _last_ );

        template< typename ForwardIterator >
        typename std::enable_if_t
        <
                 is_cpp17_forward_iterator_v< ForwardIterator > &&
                !is_prefix_vector_iterator_v < ForwardIterator > &&
                 std::is_constructible_v
                 <
                        value_type,
                        typename std::iterator_traits< ForwardIterator >::reference
                 >,
                 iterator
        >
        insert ( const_iterator _position_, ForwardIterator _first_, ForwardIterator _last_ );

        iterator insert ( const_iterator _position_, std::initializer_list< value_type > _list_ )
        { return insert( _position_, _list_.begin(), _list_.end() ); }

        iterator erase ( const_iterator _position_                       );
        iterator erase ( const_iterator    _begin_, const_iterator _end_ );

        void resize ( size_type const _count_                        );
        void resize ( size_type const _count_, const_reference _val_ );
#endif

        void swap ( prefix_vector & ) noexcept;

        void clear () noexcept
        {
                size_type old_size = size();
                _base::clear();
                _annotate_shrink( old_size );
                _invalidate_all_iterators();
        }

        bool _invariants () const;

        bool _dereferenceable ( const_iterator const * _i_                     ) const;
        bool _decrementable   ( const_iterator const * _i_                     ) const;
        bool _addable         ( const_iterator const * _i_, std::ptrdiff_t _n_ ) const;
        bool _subscriptable   ( const_iterator const * _i_, std::ptrdiff_t _n_ ) const;

private:
        void _invalidate_all_iterators ();
        void _invalidate_iterators_past ( pointer _new_last_ );

        void _vallocate   ( size_type const _count_ );
        void _vdeallocate (                         ) noexcept;

        size_type _recommend ( size_type const _new_size_ ) const noexcept;

        void _construct_at_end ( size_type const _count_                        );
        void _construct_at_end ( size_type const _count_, const_reference _val_ );

        template< typename PrefixIterator >
        typename std::enable_if_t
        <
                is_prefix_vector_iterator_v< PrefixIterator >,
                void
        >
        _construct_at_end ( PrefixIterator _begin_, PrefixIterator _end_, size_type const _count_ );

        template< typename ForwardIterator >
        typename std::enable_if_t
        <
                 is_cpp17_forward_iterator_v< ForwardIterator > &&
                !is_prefix_vector_iterator_v < ForwardIterator >,
                 void
        >
        _construct_at_end ( ForwardIterator _begin_, ForwardIterator _end_, size_type const _count_ );

        void _append ( size_type const _count_                        );
        void _append ( size_type const _count_, const_reference _val_ );

        void _update_back    (                            ) noexcept;
        void _update_element ( size_type const _position_ ) noexcept;

              iterator _make_iter ( pointer       _ptr_ )       noexcept;
        const_iterator _make_iter ( pointer const _ptr_ ) const noexcept;

        void    _swap_out_circular_buffer ( split_buffer< value_type, allocator_type & > & _buffer_                );
        pointer _swap_out_circular_buffer ( split_buffer< value_type, allocator_type & > & _buffer_, pointer _ptr_ );

        void _move_range ( pointer _from_s_, pointer _from_e_, pointer _to_ );

        void _move_assign ( prefix_vector & _other_, std::true_type  ) noexcept( std::is_nothrow_move_assignable_v< allocator_type > );
        void _move_assign ( prefix_vector & _other_, std::false_type ) noexcept( _alloc_traits::is_always_equal::value );

        void _destruct_at_end ( pointer _new_last_ ) noexcept
        {
                _invalidate_iterators_past( _new_last_ );

                size_type old_size = size();
                _base::_destruct_at_end( _new_last_ );
                _annotate_shrink( old_size );
        }

        template< typename U >
        inline void _push_back_slow_path ( U && _val_ );

        template< typename... Args >
        inline void _emplace_back_slow_path ( Args&&... _args_ );

#ifdef NPL_HAS_ASAN
        void _annotate_contiguous_container ( void const * _beg_, void const * _end_,
                                              void const * _old_mid_,
                                              void const * _new_mid_ ) const
        {
                if( _beg_ && std::is_same_v< allocator_type, _default_allocator_type > )
                {
                        __sanitizer_annotate_contiguous_container( _beg_, _end_, _old_mid_, _new_mid_ );
                }
        }
#else
        void _annotate_contiguous_container ( void const *, void const *, void const *, void const * ) const noexcept {}
#endif
        void _annotate_new ( size_type _current_size_ ) const noexcept
        {
                _annotate_contiguous_container( data(), data() + capacity(),
                                                data() + capacity(), data() + _current_size_ );
        }

        void _annotate_delete () const noexcept
        {
                _annotate_contiguous_container( data(), data() + capacity(),
                                                data() + size(), data() + capacity() );
        }

        void _annotate_increase ( size_type _n_ ) const noexcept
        {
                _annotate_contiguous_container( data(), data() + capacity(),
                                                data() + size(), data() + size() + _n_ );
        }

        void _annotate_shrink ( size_type _old_size_ ) const noexcept
        {
                _annotate_contiguous_container( data(), data() + capacity(),
                                                data() + _old_size_, data() + size() );
        }

        struct _construct_transaction
        {
                explicit _construct_transaction ( prefix_vector & _prefix_, size_type const _count_ )
                        : prefix_  ( _prefix_ ),
                          position_( _prefix_.end_ ),
                          new_end_ ( _prefix_.end_ + _count_ )
                {
#ifdef NPL_HAS_ASAN
                        prefix_._annotate_increase( _count_ );
#endif
                }

                ~_construct_transaction ()
                {
                        prefix_.end_ = position_;
#ifdef NPL_HAS_ASAN
                        if( position_ != new_end_ )
                        {
                                prefix_._annotate_shrink( new_end_ - prefix_.begin_ );
                        }
#endif
                }

                prefix_vector &      prefix_  ;
                pointer             position_;
                const_pointer const new_end_ ;

        private:
                _construct_transaction             ( _construct_transaction const & ) = delete;
                _construct_transaction & operator= ( _construct_transaction const & ) = delete;
        };

        template< typename... Args >
        void _construct_one_at_end ( Args... _args_ )
        {
                _construct_transaction tx( *this, 1 );

                _alloc_traits::construct( this->_alloc(), mem::to_address( tx.position_ ), NPL_FWD( _args_ )... );
                ++tx.position_;
        }
};


template< typename InputIterator,
          typename Alloc = std::allocator< _iter_value_type< InputIterator > >,
          typename       = std::enable_if< _is_allocator< Alloc >::value >
          >
prefix_vector ( InputIterator, InputIterator )
        -> prefix_vector< _iter_value_type< InputIterator >, Alloc >;

template< typename InputIterator,
          typename Alloc,
          typename = std::enable_if< _is_allocator< Alloc >::value >
          >
prefix_vector ( InputIterator, InputIterator, Alloc )
        -> prefix_vector< _iter_value_type< InputIterator >, Alloc >;

template< typename T,
          typename Alloc  = std::allocator< T >,
          typename        = std::enable_if< _is_allocator< Alloc >::value >,
          typename Traits = std::allocator_traits< Alloc >
          >
prefix_vector ( typename Traits::size_type const, T )
        -> prefix_vector< T, Alloc >;

template< typename T,
          typename Alloc,
          typename        = std::enable_if< _is_allocator< Alloc >::value >,
          typename Traits = std::allocator_traits< Alloc >
          >
prefix_vector ( typename Traits::size_type const, T, Alloc )
        -> prefix_vector< T, Alloc >;


template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_swap_out_circular_buffer ( split_buffer< value_type, allocator_type & > & _buffer_ )
{
        _annotate_delete();

        mem::_construct_backward_with_exception_guarantees( this->_alloc(), this->begin_, this->end_, _buffer_.begin_ );

        std::swap( this->begin_    , _buffer_.begin_     );
        std::swap( this->end_      , _buffer_.end_       );
        std::swap( this->_end_cap(), _buffer_._end_cap() );

        _buffer_.first_ = _buffer_.begin_;
        _annotate_new( size() );
        _invalidate_all_iterators();
}

template< typename T, typename Allocator >
typename prefix_vector< T, Allocator >::pointer
prefix_vector< T, Allocator >::_swap_out_circular_buffer ( split_buffer< value_type, allocator_type & > & _buffer_, pointer _ptr_ )
{
        _annotate_delete();

        pointer ret = _buffer_.begin_;

        mem::_construct_backward_with_exception_guarantees( this->_alloc(), this->begin_,      _ptr_, _buffer_.begin_ );
        mem::_construct_forward_with_exception_guarantees ( this->_alloc(),        _ptr_, this->end_, _buffer_.end_   );

        std::swap( this->begin_    , _buffer_->begin_    );
        std::swap( this->end_      , _buffer_.end_       );
        std::swap( this->_end_cap(), _buffer_._end_cap() );

        _buffer_.first_ = _buffer_.begin_;
        _annotate_new( size() );
        _invalidate_all_iterators();

        return ret;
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_vallocate ( size_type const _count_ )
{
        NPL_ASSERT( _count_ <= max_size(), "prefix_vector::_vallocate: size > max_size" );

        this->begin_ = this->end_ = _alloc_traits::allocate( this->_alloc(), _count_ );
        this->end_cap_ = this->begin_ + _count_;

        _annotate_new( 0 );
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_vdeallocate () noexcept
{
        if( this->begin_ != nullptr )
        {
                clear();
                _alloc_traits::deallocate( this->_alloc(), this->begin_, capacity() );
                this->begin_ = this->end_ = this->end_cap_ = nullptr;
        }
}

template< typename T, typename Allocator >
typename prefix_vector< T, Allocator >::size_type
prefix_vector< T, Allocator >::max_size () const noexcept
{
        return std::min< size_type >( _alloc_traits::max_size( this->_alloc() ), std::numeric_limits< difference_type >::max() );
}

template< typename T, typename Allocator >
inline
typename prefix_vector< T, Allocator >::size_type
prefix_vector< T, Allocator >::_recommend ( size_type const _new_size_ ) const noexcept
{
        size_type const ms = max_size();

        NPL_ASSERT( _new_size_ < ms, "prefix_vector::_recommend: new size > max size" );

        size_type const cap = capacity();

        if( cap >= ms / 2 )
        {
                return ms;
        }

        return std::max< size_type >( 1.618 * cap, _new_size_ );
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_construct_at_end ( size_type const _count_ )
{
        _construct_transaction tx( *this, _count_ );

        const_pointer new_end = tx.new_end_;

        for( pointer pos = tx.position_; pos != new_end; ++pos, tx.position_ = pos )
        {
                _alloc_traits::construct( this->_alloc(), mem::to_address( pos ) );
        }
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_construct_at_end ( size_type const _count_, const_reference _val_ )
{
        _construct_transaction tx( *this, _count_ );

        const_pointer new_end = tx.new_end_;

        for( pointer pos = tx.position_; pos != new_end; ++pos, tx.position_ = pos )
        {
                _alloc_traits::construct( this->_alloc(), mem::to_address( pos ), _val_ );
        }
}

template< typename T, typename Allocator >
template< typename PrefixIterator >
typename std::enable_if_t
<
        is_prefix_vector_iterator_v< PrefixIterator >,
        void
>
prefix_vector< T, Allocator >::_construct_at_end ( PrefixIterator _first_, PrefixIterator _last_, size_type const _count_ )
{
        _construct_transaction tx( *this, _count_ );

        mem::_construct_range_forward( this->_alloc(), _first_, _last_, tx.position_ );
}

template< typename T, typename Allocator >
template< typename ForwardIterator >
typename std::enable_if_t
<
         is_cpp17_forward_iterator_v< ForwardIterator > &&
        !is_prefix_vector_iterator_v < ForwardIterator >,
         void
>
prefix_vector< T, Allocator >::_construct_at_end ( ForwardIterator _first_, ForwardIterator _last_, size_type const _count_ )
{
        _construct_transaction tx( *this, _count_ );

        const_pointer new_end = tx.new_end_;

        for( pointer pos = tx.position_; ( pos != new_end ) && ( _first_ != _last_ ); ++pos, ++_first_, tx.position_ = pos )
        {
                value_type val = *_first_;

                if( !empty() )
                {
                        val += *( pos - 1 );
                }

                _alloc_traits::construct( this->_alloc(), mem::to_address( pos ), val );
        }
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_append ( size_type const _count_ )
{
        if( static_cast< size_type >( this->end_cap_ - this->end_ ) >= _count_ )
        {
                this->_construct_at_end( _count_ );
        }
        else
        {
                allocator_type & alloc = this->_alloc();
                split_buffer< value_type, allocator_type & > buffer( _recommend( size() + _count_ ), size(), alloc );
                buffer._construct_at_end( _count_ );
                _swap_out_circular_buffer( buffer );
        }
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_append ( size_type const _count_, const_reference _val_ )
{
        if( static_cast< size_type >( this->end_cap_ - this->end_ ) >= _count_ )
        {
                this->_construct_at_end( _count_, _val_ );
        }
        else
        {
                allocator_type & alloc = this->_alloc();
                split_buffer< value_type, allocator_type & > buffer( _recommend( size() + _count_ ), size(), alloc );
                buffer._construct_at_end( _count_, _val_ );
                _swap_out_circular_buffer( buffer );
        }
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_update_back () noexcept
{
        if( size() < 2 )
        {
                return;
        }

        *( this->end_ - 1 ) += *( this->end_ - 2 );
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_update_element ( size_type const _position_ ) noexcept
{
        if( size() < 2 || _position_ == 0 )
        {
                return;
        }

        this->begin_[ _position_ ] += this->begin_[ _position_ - 1 ];
}

template< typename T, typename Allocator >
prefix_vector< T, Allocator >::prefix_vector ( size_type const _count_ )
{
        if( _count_ > 0 )
        {
                _vallocate( _count_ );
        }
}

template< typename T, typename Allocator >
prefix_vector< T, Allocator >::prefix_vector ( size_type const _count_, allocator_type const & _alloc_ )
        : _base( _alloc_ )
{
        if( _count_ > 0 )
        {
                _vallocate( _count_ );
        }
}

template< typename T, typename Allocator >
prefix_vector< T, Allocator >::prefix_vector ( size_type const _count_, value_type const & _val_ )
{
        if( _count_ > 0 )
        {
                _vallocate( _count_ );

                for( size_type i = 0; i < _count_; ++i )
                {
                        _construct_at_end( 1, _val_ );
                        _update_back();
                }
        }
}

template< typename T, typename Allocator >
prefix_vector< T, Allocator >::prefix_vector ( size_type const _count_, value_type const & _val_, allocator_type const & _alloc_ )
        : _base( _alloc_ )
{
        if( _count_ > 0 )
        {
                _vallocate( _count_ );

                for( size_type i = 0; i < _count_; ++i )
                {
                        _construct_at_end( 1, _val_ );
                        _update_back();
                }
        }
}

template< typename T, typename Allocator >
template< typename PrefixIterator >
prefix_vector< T, Allocator >::prefix_vector ( PrefixIterator _first_,
                typename std::enable_if_t
                <
                        is_prefix_vector_iterator_v< PrefixIterator > &&
                        std::is_constructible_v
                        <
                                value_type,
                                typename std::iterator_traits< PrefixIterator >::reference
                        >,
                PrefixIterator > _last_ )
{
        size_type count = static_cast< size_type >( std::distance( _first_, _last_ ) );

        if( count > 0 )
        {
                _vallocate( count );
                _construct_at_end( _first_, _last_, count );
        }
}

template< typename T, typename Allocator >
template< typename PrefixIterator >
prefix_vector< T, Allocator >::prefix_vector ( PrefixIterator _first_, PrefixIterator _last_, allocator_type const & _alloc_,
                std::enable_if_t
                <
                        is_prefix_vector_iterator_v< PrefixIterator > &&
                        std::is_constructible_v
                        <
                                value_type,
                                typename std::iterator_traits< PrefixIterator >::reference
                        >
                > * )
        : _base( _alloc_ )
{
        size_type count = static_cast< size_type >( std::distance( _first_, _last_ ) );

        if( count > 0 )
        {
                _vallocate( count );
                _construct_at_end( _first_, _last_, count );
        }
}

template< typename T, typename Allocator >
template< typename InputIterator >
prefix_vector< T, Allocator >::prefix_vector ( InputIterator _first_,
                typename std::enable_if_t
                <
                         is_cpp17_input_iterator_v  < InputIterator > &&
                        !is_cpp17_forward_iterator_v< InputIterator > &&
                        !is_prefix_vector_iterator_v < InputIterator > &&
                         std::is_constructible_v
                         <
                                value_type,
                                typename std::iterator_traits< InputIterator >::reference
                         >,
                InputIterator > _last_ )
{
        for( ; _first_ != _last_; ++_first_ )
        {
                _emplace_back( *_first_ );
        }
}

template< typename T, typename Allocator >
template< typename InputIterator >
prefix_vector< T, Allocator >::prefix_vector ( InputIterator _first_, InputIterator _last_, allocator_type const & _alloc_,
                typename std::enable_if_t
                <
                         is_cpp17_input_iterator_v  < InputIterator > &&
                        !is_cpp17_forward_iterator_v< InputIterator > &&
                        !is_prefix_vector_iterator_v < InputIterator > &&
                         std::is_constructible_v
                         <
                                value_type,
                                typename std::iterator_traits< InputIterator >::reference
                         >
                > * )
                : _base( _alloc_ )
{
        for( ; _first_ != _last_; ++_first_ )
        {
                _emplace_back( *_first_ );
        }
}

template< typename T, typename Allocator >
template< typename ForwardIterator >
prefix_vector< T, Allocator >::prefix_vector ( ForwardIterator _first_,
                typename std::enable_if_t
                <
                         is_cpp17_forward_iterator_v< ForwardIterator > &&
                        !is_prefix_vector_iterator_v < ForwardIterator > &&
                        std::is_constructible_v
                        <
                                value_type,
                                typename std::iterator_traits< ForwardIterator >::reference
                        >,
                ForwardIterator > _last_ )
{
        size_type count = static_cast< size_type >( std::distance( _first_, _last_ ) );

        if( count > 0 )
        {
                _vallocate( count );

                for( size_type index = 0; ( index < count ) && ( _first_ != _last_ ); ++index, ++_first_ )
                {
                        _construct_at_end( 1, *_first_ );
                        _update_back();
                }
        }
}

template< typename T, typename Allocator >
template< typename ForwardIterator >
prefix_vector< T, Allocator >::prefix_vector ( ForwardIterator _first_, ForwardIterator _last_, allocator_type const & _alloc_,
                std::enable_if_t
                <
                        is_cpp17_forward_iterator_v< ForwardIterator > &&
                        !is_prefix_vector_iterator_v < ForwardIterator > &&
                        std::is_constructible_v
                        <
                                value_type,
                                typename std::iterator_traits< ForwardIterator >::reference
                        >
                > * )
        : _base( _alloc_ )
{
        size_type count = static_cast< size_type >( std::distance( _first_, _last_ ) );

        if( count > 0 )
        {
                _vallocate( count );

                for( size_type index = 0; ( index < count ) && ( _first_ != _last_ ); ++index, ++_first_ )
                {
                        _construct_at_end( 1, *_first_ );
                        _update_back();
                }
        }
}

template< typename T, typename Allocator >
prefix_vector< T, Allocator >::prefix_vector ( prefix_vector const & _other_ )
        : _base( _alloc_traits::select_on_container_copy_construction( _other_._alloc() ) )
{
        size_type count = _other_.size();

        if( count > 0 )
        {
                _vallocate( count );
                _construct_at_end( _other_.begin(), _other_.end(), count );
        }
}

template< typename T, typename Allocator >
prefix_vector< T, Allocator >::prefix_vector ( prefix_vector const & _other_, _identity< allocator_type > const & _alloc_ )
        : _base( _alloc_ )
{
        size_type count = _other_.size();

        if( count > 0 )
        {
                _vallocate( count );
                _construct_at_end( _other_.begin(), _other_.end(), count );
        }
}

template< typename T, typename Allocator >
inline
prefix_vector< T, Allocator >::prefix_vector ( prefix_vector && _other_ ) noexcept
        : _base( NPL_MOVE( _other_._alloc() ) )
{
        this->begin_   = _other_.begin_  ;
        this->end_     = _other_.end_    ;
        this->end_cap_ = _other_.end_cap_;

        _other_.begin_ = _other_.end_ = _other_.end_cap_ = nullptr;
}

template< typename T, typename Allocator >
inline
prefix_vector< T, Allocator >::prefix_vector ( prefix_vector && _other_, _identity< allocator_type > const & _alloc_ )
        : _base( _alloc_ )
{
        if( _alloc_ == _other_._alloc() )
        {
                this->begin_   = _other_.begin_  ;
                this->end_     = _other_.end_    ;
                this->end_cap_ = _other_.end_cap_;

                _other_.begin_ = _other_.end_ = _other_.end_cap_ = nullptr;
        }
        else
        {
                using mit = std::move_iterator< iterator >;
                assign( mit( _other_.begin() ), mit( _other_.end() ) );
        }
}

template< typename T, typename Allocator >
inline
prefix_vector< T, Allocator >::prefix_vector ( std::initializer_list< value_type > _list_ )
{
        if( _list_.size() > 0 )
        {
                _vallocate( _list_.size() );

                for( auto begin = _list_.begin(); begin != _list_.end(); ++begin )
                {
                        _construct_at_end( 1, *begin );
                        _update_back();
                }
        }
}

template< typename T, typename Allocator >
inline
prefix_vector< T, Allocator >::prefix_vector ( std::initializer_list< value_type > _list_, allocator_type const & _alloc_ )
        : _base( _alloc_ )
{
        if( _list_.size() > 0 )
        {
                size_type count = _list_.size();

                _vallocate( _list_.size() );

                for( auto begin = _list_.begin(); begin != _list_.end(); ++begin )
                {
                        _construct_at_end( 1, *begin );
                        _update_back();
                }
        }
}

template< typename T, typename Allocator >
inline
prefix_vector< T, Allocator > &
prefix_vector< T, Allocator >::operator= ( prefix_vector && _other_ )
        noexcept( ( noexcept_move_assign_container_v< Allocator, _alloc_traits > ) )
{
        _move_assign( _other_, std::integral_constant< bool,
                        _alloc_traits::propagate_on_container_move_assignment::value >() );
        return *this;
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_move_assign ( prefix_vector & _other_, std::false_type )
        noexcept( _alloc_traits::is_always_equal::value )
{
        if( _base::_alloc() != _other_._alloc() )
        {
                using mit = std::move_iterator< iterator >;
                assign( mit( _other_.begin() ), mit( _other_.end() ) );
        }
        else
        {
                _move_assign( _other_, std::true_type() );
        }
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::_move_assign ( prefix_vector & _other_, std::true_type )
        noexcept( std::is_nothrow_move_assignable_v< allocator_type > )
{
        _vdeallocate();
        _base::_move_assign_alloc( _other_ );

        this->begin_   = _other_.begin_  ;
        this->end_     = _other_.end_    ;
        this->end_cap_ = _other_.end_cap_;

        _other_.begin_ = _other_.end_ = _other_.end_cap_ = nullptr;
}

template< typename T, typename Allocator >
inline
prefix_vector< T, Allocator > &
prefix_vector< T, Allocator >::operator= ( prefix_vector const & _other_ )
{
        if( this != &_other_ )
        {
                _base::_copy_assign_alloc( _other_ );
                assign( _other_.begin(), _other_.end() );
        }
        return *this;
}

template< typename T, typename Allocator >
template< typename PrefixIterator >
typename std::enable_if_t
<
        is_prefix_vector_iterator_v< PrefixIterator > &&
        std::is_constructible_v
        <
                T,
                typename std::iterator_traits< PrefixIterator >::reference
        >,
        void
>
prefix_vector< T, Allocator >::assign ( PrefixIterator _first_, PrefixIterator _last_ )
{
        size_type new_size = static_cast< size_type >( std::distance( _first_, _last_ ) );

        if( new_size <= capacity() )
        {
                PrefixIterator mid = _last_;
                bool growing = false;

                if( new_size > size() )
                {
                        growing = true;
                        mid = _first_;
                        std::advance( mid, size() );
                }

                pointer mid_ptr = std::copy( _first_, mid, this->begin_ );

                if( growing )
                {
                        _construct_at_end( mid, _last_, new_size - size() );
                }
                else
                {
                        this->_destruct_at_end( mid_ptr );
                }
        }
        else
        {
                _vdeallocate();
                _vallocate( _recommend( new_size ) );
                _construct_at_end( _first_, _last_, new_size );
        }
        _invalidate_all_iterators();
}

template< typename T, typename Allocator >
template< typename InputIterator >
typename std::enable_if_t
<
         is_cpp17_input_iterator_v < InputIterator > &&
        !is_prefix_vector_iterator_v< InputIterator > &&
         std::is_constructible_v
         <
                T,
                typename std::iterator_traits< InputIterator >::reference
         >,
         void
>
prefix_vector< T, Allocator >::assign ( InputIterator _first_, InputIterator _last_ )
{
        clear();
        for( ; _first_ != _last_; ++_first_ )
        {
                _emplace_back( *_first_ );
        }
}

#if 0
template< typename T, typename Allocator >
template< typename ForwardIterator >
typename std::enable_if_t
<
         is_cpp17_forward_iterator_v< ForwardIterator > &&
        !is_prefix_vector_iterator_v < ForwardIterator > &&
         std::is_constructible_v
         <
                T,
                typename std::iterator_traits< ForwardIterator >::reference
         >,
         void
>
prefix_vector< T, Allocator >::assign ( ForwardIterator _first_, ForwardIterator _last_ )
{

}
#endif

#if 0
template< typename T, typename Allocator >
void prefix_vector< T, Allocator >::assign ( size_type const _count_, const_reference _val_ )
{
        if( _count_ <= capacity() )
        {
                size_type sz = size();

                std::fill_n( this->begin_, std::min( _count_, sz ), _val_ );

                if( _count_ > sz )
                {
                        _construct_at_end( _count_ - sz, _val_ );
                }
                else
                {
                        this->_destruct_at_end( this->_begin + _count_ );
                }
        }
        else
        {
                _vdeallocate();
                _vallocate( _recommend( static_cast< size_type >( _count_ ) ) );
                _construct_at_end( _count_, _val_ );
        }
        _invalidate_all_iterators();
}
#endif

template< typename T, typename Allocator >
inline
typename prefix_vector< T, Allocator >::iterator
prefix_vector< T, Allocator >::_make_iter ( pointer _ptr_ ) noexcept
{
        return iterator( _ptr_ );
}

template< typename T, typename Allocator >
inline
typename prefix_vector< T, Allocator >::const_iterator
prefix_vector< T, Allocator >::_make_iter ( pointer const _ptr_ ) const noexcept
{
        return const_iterator( _ptr_ );
}

template< typename T, typename Allocator >
inline
typename prefix_vector< T, Allocator >::iterator
prefix_vector< T, Allocator >::begin () noexcept
{
        return _make_iter( this->begin_ );
}

template< typename T, typename Allocator >
inline
typename prefix_vector< T, Allocator >::const_iterator
prefix_vector< T, Allocator >::begin () const noexcept
{
        return _make_iter( this->begin_ );
}

template< typename T, typename Allocator >
inline
typename prefix_vector< T, Allocator >::iterator
prefix_vector< T, Allocator >::end () noexcept
{
        return _make_iter( this->end_ );
}

template< typename T, typename Allocator >
inline
typename prefix_vector< T, Allocator >::const_iterator
prefix_vector< T, Allocator >::end () const noexcept
{
        return _make_iter( this->end_ );
}

template< typename T, typename Allocator >
inline
NPL_ALWAYS_INLINE
typename prefix_vector< T, Allocator >::reference
prefix_vector< T, Allocator >::operator[] ( size_type const _index_ ) noexcept
{
        NPL_ASSERT( _index_ < size(), "prefix_vector::operator[]: index out of bounds" );

        return this->begin_[ _index_ ];
}

template< typename T, typename Allocator >
inline
NPL_ALWAYS_INLINE
typename prefix_vector< T, Allocator >::const_reference
prefix_vector< T, Allocator >::operator[] ( size_type const _index_ ) const noexcept
{
        NPL_ASSERT( _index_ < size(), "prefix_vector::operator[]: index out of bounds" );

        return this->begin_[ _index_ ];
}

template< typename T, typename Allocator >
inline
auto &
prefix_vector< T, Allocator >::operator+= ( prefix_vector< T, Allocator > const & _other_ ) noexcept
{
        size_type common = std::min< size_type >( size(), _other_.size() );

        for( size_type i = 0; i < common; ++i )
        {
                this->begin_[ i ] += _other_.begin_[ i ];
        }

        if( _other_.size() > size() )
        {
                for( size_type i = common; i < _other_.size(); ++i )
                {
                        _emplace_back( _other_.begin_[ i ] );
                }
        }
        else
        {
                for( size_type i = size() - 1; i >= common; --i )
                {
                        this->begin_[ i ] = element_at( i );
                }
                for( size_type i = common; i < size(); ++i )
                {
                        _update_element( i );
                }
        }

        return *this;
}

template< typename T, typename Allocator >
inline
auto
prefix_vector< T, Allocator >::operator+ ( prefix_vector< T, Allocator > const & _other_ ) const
{
        prefix_vector< T, Allocator > res( *this );

        res += _other_;

        return res;
}

template< typename T, typename Allocator >
inline
auto &
prefix_vector< T, Allocator >::operator-= ( prefix_vector< T, Allocator > const & _other_ ) noexcept
{
        size_type common = std::min< size_type >( size(), _other_.size() );

        for( size_type i = 0; i < common; ++i )
        {
                this->begin_[ i ] -= _other_.begin_[ i ];
        }

        if( _other_.size() > size() )
        {
                for( size_type i = common; i < _other_.size(); ++i )
                {
                        _emplace_back( value_type() - _other_.begin_[ i ] );
                }
        }
        else
        {
                for( size_type i = size() - 1; i >= common; --i )
                {
                        this->begin_[ i ] = element_at( i );
                }
                for( size_type i = common; i < size(); ++i )
                {
                        _update_element( i );
                }
        }

        return *this;
}

template< typename T, typename Allocator >
inline
auto
prefix_vector< T, Allocator >::operator- ( prefix_vector< T, Allocator > const & _other_ ) const
{
        prefix_vector< T, Allocator > res( *this );

        res -= _other_;

        return res;
}

template< typename T, typename Allocator >
bool
prefix_vector< T, Allocator >::operator== ( prefix_vector< T, Allocator > const & _other_ ) const noexcept
{
        if( size() != _other_.size() )
        {
                return false;
        }

        for( size_type i = 0; i < size(); ++i )
        {
                if( at( i ) != _other_.at( i ) )
                {
                        return false;
                }
        }
        return true;
}

template< typename T, typename Allocator >
bool
prefix_vector< T, Allocator >::operator!= ( prefix_vector< T, Allocator > const & _other_ ) const noexcept
{
        return !operator==( _other_ );
}

template< typename T, typename Allocator >
template< typename PrefixIterator >
typename std::enable_if_t
<
        is_prefix_vector_iterator_v< PrefixIterator > &&
        std::is_constructible_v
        <
                T,
                typename std::iterator_traits< PrefixIterator >::reference
        >,
        bool
>
prefix_vector< T, Allocator >::operator== ( PrefixIterator _first_ ) const noexcept
{
        for( auto begin = this->begin(); begin != this->end(); ++begin, ++_first_ )
        {
                if( *_first_ != *begin )
                {
                        return false;
                }
        }
        return true;
}

template< typename T, typename Allocator >
template< typename InputIterator >
typename std::enable_if_t
<
        !is_prefix_vector_iterator_v < InputIterator > &&
        !is_cpp17_forward_iterator_v< InputIterator > &&
         is_cpp17_input_iterator_v  < InputIterator > &&
         std::is_constructible_v
         <
                T,
                typename std::iterator_traits< InputIterator >::reference
         >,
         bool
>
prefix_vector< T, Allocator >::operator== ( InputIterator _first_ ) const noexcept
{
        for( size_type i = 0; i < size(); ++i, ++_first_ )
        {
                if( *_first_ != element_at( i ) )
                {
                        return false;
                }
        }
        return true;
}

template< typename T, typename Allocator >
template< typename ForwardIterator >
typename std::enable_if_t
<
        !is_prefix_vector_iterator_v< ForwardIterator > &&
         is_cpp17_forward_iterator_v< ForwardIterator > &&
         std::is_constructible_v
         <
                T,
                typename std::iterator_traits< ForwardIterator >::reference
         >,
         bool
>
prefix_vector< T, Allocator >::operator== ( ForwardIterator _first_ ) const noexcept
{
        for( size_type i = 0; i < this->size(); ++i, ++_first_ )
        {
                if( *_first_ != this->element_at( i ) )
                {
                        return false;
                }
        }
        return true;
}

template< typename T, typename Allocator >
typename prefix_vector< T, Allocator >::reference
prefix_vector< T, Allocator >::at ( size_type const _index_ ) noexcept
{
        NPL_ASSERT( _index_ < size(), "prefix_vector::at: index out of bounds" );

        return this->begin_[ _index_ ];
}

template< typename T, typename Allocator >
typename prefix_vector< T, Allocator >::const_reference
prefix_vector< T, Allocator >::at ( size_type const _index_ ) const noexcept
{
        NPL_ASSERT( _index_ < size(), "prefix_vector::at: index out of bounds" );

        return this->begin_[ _index_ ];
}

template< typename T, typename Allocator >
typename prefix_vector< T, Allocator >::value_type
prefix_vector< T, Allocator >::element_at ( size_type const _index_ ) const noexcept
{
        return range( _index_, _index_ );
}

template< typename T, typename Allocator >
typename prefix_vector< T, Allocator >::value_type
prefix_vector< T, Allocator >::range ( size_type const _x_, size_type const _y_ ) const noexcept
{
        NPL_ASSERT( !empty()                  , "prefix_vector::range: called on empty prefix_vector" );
        NPL_ASSERT( _x_ <= _y_ && _y_ < size(), "prefix_vector::range: index out of bounds"           );

        return  _x_ == 0 ?
                this->begin_[ _y_ ] :
                this->begin_[ _y_ ] - this->begin_[ _x_ - 1 ];
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::reserve ( size_type const _size_ )
{
        if( _size_ > capacity() )
        {
                allocator_type & alloc = this->_alloc();
                split_buffer< value_type, allocator_type & > buffer( _size_, size(), alloc );
                _swap_out_circular_buffer( buffer );
        }
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::shrink_to_fit () noexcept
{
        if( capacity() > size() )
        {
                allocator_type & alloc = this->_alloc();
                split_buffer< value_type, allocator_type & > buffer( size(), size(), alloc );
                _swap_out_circular_buffer( buffer );
        }
}

template< typename T, typename Allocator >
template< typename U >
void
prefix_vector< T, Allocator >::_push_back_slow_path ( U && _val_ )
{
        allocator_type & alloc = this->_alloc();

        split_buffer< value_type, allocator_type & > buffer( _recommend( size() + 1 ), size(), alloc );

        _alloc_traits::construct( alloc, mem::to_address( buffer.end_ ), NPL_FWD( _val_ ) );
        buffer.end_++;

        _swap_out_circular_buffer( buffer );
}

template< typename T, typename Allocator >
inline
void
prefix_vector< T, Allocator >::push_back ( const_reference _val_ )
{
        if( this->end_ != this->end_cap_ )
        {
                _construct_one_at_end( _val_ );
        }
        else
        {
                _push_back_slow_path( _val_ );
        }
        _update_back();
}

template< typename T, typename Allocator >
inline
void
prefix_vector< T, Allocator >::push_back ( value_type && _val_ )
{
        if( this->end_ != this->end_cap_ )
        {
                _construct_one_at_end( NPL_MOVE( _val_ ) );
        }
        else
        {
                _push_back_slow_path( NPL_MOVE( _val_ ) );
        }
        _update_back();
}

template< typename T, typename Allocator >
template< typename... Args >
void
prefix_vector< T, Allocator >::_emplace_back_slow_path ( Args&&... _args_ )
{
        allocator_type & alloc = this->_alloc();

        split_buffer< value_type, allocator_type & > buffer( _recommend( size() + 1 ), size(), alloc );

        _alloc_traits::construct( alloc, mem::to_address( buffer.end_ ), NPL_FWD( _args_ )... );
        buffer.end_++;

        _swap_out_circular_buffer( buffer );
}

template< typename T, typename Allocator >
template< typename... Args >
inline
typename prefix_vector< T, Allocator >::reference
prefix_vector< T, Allocator >::emplace_back ( Args&&... _args_ )
{
        if( this->end_ != this->end_cap_ )
        {
                _construct_one_at_end( NPL_FWD( _args_ )... );
        }
        else
        {
                _emplace_back_slow_path( NPL_FWD( _args_ )... );
        }
        _update_back();

        return this->back();
}

template< typename T, typename Allocator >
inline
void
prefix_vector< T, Allocator >::pop_back ()
{
        NPL_ASSERT( !empty(), "prefix_vector::pop_back: called on empty prefix array" );

        this->_destruct_at_end( this->end_ - 1 );
}

#if 0
template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::resize ( size_type const _size_ )
{
        size_type current_size = size();

        if( current_size < _size_ )
        {
                this->_append( _size_ - current_size );
        }
        else
        {
                this->_destruct_at_end( this->begin_ + _size_ );
        }
}

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::resize ( size_type const _size_, const_reference _val_ )
{
        size_type current_size = size();

        if( current_size < _size_ )
        {
                this->_append( _size_ - current_size, _val_ );
        }
        else
        {
                this->_destruct_at_end( this->begin_ + _size_ );
        }
}
#endif

template< typename T, typename Allocator >
void
prefix_vector< T, Allocator >::swap ( prefix_vector & _other_ ) noexcept
{
        NPL_ASSERT( _alloc_traits::propagate_on_container_swap::value || this->_alloc() == _other_._alloc(),
                        "prefix_vector::swap: if lhs.alloc != rhs.alloc, alloc_type needs to propagate on swap" );

        std::swap( this->begin_  , _other_.begin_   );
        std::swap( this->end_    , _other_.end_     );
        std::swap( this->end_cap_, _other_.end_cap_ );

        mem::_swap_allocator( this->_alloc(), _other_._alloc(),
                        std::integral_constant< bool, _alloc_traits::propagate_on_container_swap::value >() );
}

template< typename T, typename Allocator >
inline
void
prefix_vector< T, Allocator >::_invalidate_all_iterators ()
{}

template< typename T, typename Allocator >
inline
void
prefix_vector< T, Allocator >::_invalidate_iterators_past ( [[ maybe_unused ]] pointer _new_last_ )
{}

template< typename T, typename Allocator >
bool
prefix_vector< T, Allocator >::_invariants () const
{
        if( this->begin_ == nullptr )
        {
                if( this->end_ != nullptr || this->end_cap_ != nullptr )
                {
                        return false;
                }
        }
        else
        {
                if( this->begin_ > this->end_ )
                {
                        return false;
                }
                if( this->begin_ == this->end_cap_ )
                {
                        return false;
                }
                if( this->end_ > this->end_cap_ )
                {
                        return false;
                }
        }
        return true;
}

template< typename T, typename Allocator >
bool
prefix_vector< T, Allocator >::_dereferenceable ( const_iterator const * _i_ ) const
{
        return this->begin_ <= _i_->base() && _i_->base() < this->end_;
}

template< typename T, typename Allocator >
bool
prefix_vector< T, Allocator >::_decrementable ( const_iterator const * _i_ ) const
{
        return this->begin_ < _i_->base() && _i_->base() <= this->end_;
}

template< typename T, typename Allocator >
bool
prefix_vector< T, Allocator >::_addable ( const_iterator const * _i_, std::ptrdiff_t _n_ ) const
{
        const_pointer p = _i_->base() + _n_;
        return this->begin_ <= p && p <= this->end_;
}

template< typename T, typename Allocator >
bool
prefix_vector< T, Allocator >::_subscriptable ( const_iterator const * _i_, std::ptrdiff_t _n_ ) const
{
        const_pointer p = _i_->base() + _n_;
        return this->begin_ <= p && p < this->end_;
}


template< typename T, size_t Size >
struct prefix_vector_static
        : public array< T, Size >
{
        using           _base = array< T, Size >;
        using      value_type = typename _base::value_type;
        using       size_type = typename _base::size_type;
        using       reference = typename _base::reference;
        using const_reference = typename _base::const_reference;

        constexpr prefix_vector_static () noexcept {}

        constexpr prefix_vector_static ( value_type const & _val_ ) noexcept
        {
                fill( _val_ );
        }

        constexpr prefix_vector_static ( std::initializer_list< value_type > _list_ ) noexcept
        {
                fill( _list_.begin(), _list_.end() );
        }

        inline constexpr auto & operator= ( prefix_vector_static< T, Size > const & _other_ ) noexcept
        {
                fill( _other_.begin(), _other_.end() );

                return *this;
        }

        inline constexpr
        void fill ( value_type const & _val_ )
        {
                if( !this->empty() )
                {
                        this->data_[ 0 ] = _val_;

                        for( size_type i = 1; i < this->size(); ++i )
                        {
                                at( i ) = at( i - 1 ) + _val_;
                        }
                }
        }

        template< typename Iterator >
        inline constexpr
        void fill ( Iterator _first_, Iterator _last_ )
        {
                if( !this->empty() )
                {
                        this->data_[ 0 ] = *_first_++;

                        for( size_type i = 1; i < this->size() && _first_ != _last_; ++i, ++_first_ )
                        {
                                at( i ) = at( i - 1 ) + *_first_;
                        }
                }
        }

        NPL_NODISCARD
        inline constexpr
        reference at ( size_type const _index_ ) noexcept
        {
                return this->data_[ _index_ ];
        }

        NPL_NODISCARD
        inline constexpr
        const_reference at ( size_type const _index_ ) const noexcept
        {
                return this->data_[ _index_ ];
        }

        NPL_NODISCARD
        inline constexpr
        value_type element_at ( size_type const _index_ ) const noexcept
        {
                return range( _index_, _index_ );
        }

        NPL_NODISCARD
        inline constexpr
        value_type range ( size_type const _x_, size_type const _y_ ) const noexcept
        {
                NPL_ASSERT( _x_ <= _y_ && _y_ < Size, "prefix_vector_static::range: index out of bounds" );

                return  _x_ == 0 ?
                        this->data_[ _y_ ] :
                        this->data_[ _y_ ] - this->data_[ _x_ - 1 ];
        }
};


} // namespace npl
